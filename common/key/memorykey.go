package key

import (
	"crypto/ecdsa"
	"math/big"
	"reflect"

	"github.com/fletaio/fleta/encoding"

	"github.com/fletaio/fleta/common"
	ecrypto "github.com/fletaio/fleta/common/crypto"
	"github.com/fletaio/fleta/common/hash"
)

func init() {
	encoding.Register(MemoryKey{}, func(enc *encoding.Encoder, rv reflect.Value) error {
		panic("prevent encode memory key")
	}, func(dec *encoding.Decoder, rv reflect.Value) error {
		panic("prevent decode memory key")
	})
}

// MemoryKey is the in-memory crypto key
type MemoryKey struct {
	PrivKey *ecdsa.PrivateKey
	pubkey  common.PublicKey
}

// NewMemoryKey returns a MemoryKey
func NewMemoryKey() (*MemoryKey, error) {
	PrivKey, err := ecrypto.GenerateKey()
	if err != nil {
		return nil, err
	}
	ac := &MemoryKey{
		PrivKey: PrivKey,
	}
	if err := ac.calcPubkey(); err != nil {
		return nil, err
	}
	return ac, nil
}

// NewMemoryKeyFromString parse memory key by the hex string
func NewMemoryKeyFromString(sk string) (*MemoryKey, error) {
	ac := &MemoryKey{
		PrivKey: &ecdsa.PrivateKey{
			PublicKey: ecdsa.PublicKey{
				Curve: ecrypto.S256(),
			},
			D: new(big.Int),
		},
	}
	ac.PrivKey.D.SetString(sk, 16)
	ac.PrivKey.PublicKey.X, ac.PrivKey.PublicKey.Y = ac.PrivKey.Curve.ScalarBaseMult(ac.PrivKey.D.Bytes())
	if err := ac.calcPubkey(); err != nil {
		return nil, err
	}
	return ac, nil
}

// NewMemoryKeyFromBytes parse memory key by the byte array
func NewMemoryKeyFromBytes(pk []byte) (*MemoryKey, error) {
	ac := &MemoryKey{
		PrivKey: &ecdsa.PrivateKey{
			PublicKey: ecdsa.PublicKey{
				Curve: ecrypto.S256(),
			},
			D: new(big.Int),
		},
	}
	ac.PrivKey.D.SetBytes(pk)
	ac.PrivKey.PublicKey.X, ac.PrivKey.PublicKey.Y = ac.PrivKey.Curve.ScalarBaseMult(ac.PrivKey.D.Bytes())
	if err := ac.calcPubkey(); err != nil {
		return nil, err
	}
	return ac, nil
}

// Clear removes private key bytes data
func (ac *MemoryKey) Clear() {
	ac.PrivKey.D.SetBytes([]byte{0})
	ac.PrivKey.X.SetBytes([]byte{0})
	ac.PrivKey.Y.SetBytes([]byte{0})
}

func (ac *MemoryKey) calcPubkey() error {
	pk := ecrypto.CompressPubkey(&ac.PrivKey.PublicKey)
	copy(ac.pubkey[:], pk[:])
	return nil
}

// PublicKey returns the public key of the private key
func (ac *MemoryKey) PublicKey() common.PublicKey {
	return ac.pubkey
}

// Sign generates the signature of the target hash
func (ac *MemoryKey) Sign(h hash.Hash256) (common.Signature, error) {
	bs, err := ecrypto.Sign(h[:], ac.PrivKey)
	if err != nil {
		return common.Signature{}, err
	}
	var sig common.Signature
	copy(sig[:], bs)
	return sig, nil
}

// SignWithPassphrase doesn't implemented yet
func (ac *MemoryKey) SignWithPassphrase(h hash.Hash256, passphrase []byte) (common.Signature, error) {
	return common.Signature{}, nil
}

// Verify checks that the signatures is generated by the hash and the key or not
func (ac *MemoryKey) Verify(h hash.Hash256, sig common.Signature) bool {
	return ecrypto.VerifySignature(ac.pubkey[:], h[:], sig[:])
}

// Bytes returns the byte array of the key
func (ac *MemoryKey) Bytes() []byte {
	return ac.PrivKey.D.Bytes()
}
